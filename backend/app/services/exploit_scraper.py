"""
Exploit scraper service for automatically discovering and storing exploits
"""
import asyncio
from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.services.huggingface import HuggingFaceService
from app.services.perplexity_search import PerplexitySearchService
from app.models import Exploit
import uuid


class ExploitScraper:
    """Service for scraping and storing exploits from various sources"""

    # Common search queries for discovering exploits
    SEARCH_QUERIES = [
        "latest prompt injection exploits and jailbreaks 2025",
        "recent LLM jailbreak techniques GitHub",
        "prompt injection CVE vulnerabilities",
        "adversarial prompts security research",
        "ChatGPT GPT-4 jailbreak methods",
        "Claude Gemini jailbreak exploits",
        "DAN jailbreak variants and updates",
        "system prompt extraction attacks",
        "indirect prompt injection vulnerabilities",
        "LLM security bug bounty reports"
    ]

    def __init__(self, api_key: str, search_type: str = "web"):
        """
        Initialize the scraper

        Args:
            api_key: API key for Perplexity or Hugging Face
            search_type: "web" for Perplexity web search, "llm" for Hugging Face
        """
        self.search_type = search_type
        if search_type == "web":
            self.search_service = PerplexitySearchService(api_key)
        else:
            self.search_service = HuggingFaceService(api_key)

    async def scrape_exploits(self, db: AsyncSession, queries: List[str] = None) -> Dict[str, Any]:
        """
        Scrape exploits using configured search service (web or LLM)

        Args:
            db: Database session
            queries: Optional list of search queries (uses defaults if not provided)

        Returns:
            Dictionary with scraping results
        """
        if queries is None:
            queries = self.SEARCH_QUERIES

        total_found = 0
        total_added = 0
        total_duplicates = 0
        errors = []
        all_citations = []

        for query in queries:
            try:
                print(f"[{self.search_type.upper()}] Searching: {query}")

                # Use appropriate search method based on search_type
                if self.search_type == "web":
                    result = await self.search_service.search_web_for_exploits(query, max_results=10)
                else:
                    result = await self.search_service.search_exploits(query, max_results=10)

                if not result["success"]:
                    errors.append(f"Query '{query}': {result.get('error', 'Unknown error')}")
                    continue

                results = result.get("results", [])
                citations = result.get("citations", [])
                total_found += len(results)

                if citations:
                    all_citations.extend(citations)

                for item in results:
                    # Check if this exploit already exists (by title or similar content)
                    existing = await db.execute(
                        select(Exploit).where(Exploit.title == item.get("title", ""))
                    )
                    if existing.scalar_one_or_none():
                        total_duplicates += 1
                        print(f"  Skipped duplicate: {item.get('title', '')[:50]}")
                        continue

                    # Generate CVE-style ID - get the highest existing number
                    year = datetime.utcnow().year
                    latest_result = await db.execute(
                        select(Exploit.cve_id)
                        .where(Exploit.cve_id.like(f"PIE-{year}-%"))
                        .order_by(Exploit.cve_id.desc())
                        .limit(1)
                    )
                    latest_cve = latest_result.scalar()

                    if latest_cve:
                        try:
                            num = int(latest_cve.split('-')[-1])
                            next_num = num + 1
                        except:
                            next_num = 1
                    else:
                        next_num = 1

                    cve_id = f"PIE-{year}-{next_num:03d}"

                    # Extract citations for this specific item
                    item_citations = item.get("citations", [])
                    source_info = f"{self.search_type.upper()} Search: {query}"
                    if item_citations:
                        source_info += f" | Citations: {', '.join(item_citations[:3])}"

                    # Create exploit entry with separated description and exploit content
                    exploit = Exploit(
                        id=str(uuid.uuid4()),
                        cve_id=cve_id,
                        title=item.get("title", "Unknown Exploit"),
                        description=item.get("description", "No description available"),
                        exploit_content=item.get("exploit_content", ""),  # Actual jailbreak prompt/payload
                        exploit_type=item.get("exploit_type", "prompt_injection"),  # Extract from Perplexity or default
                        severity=item.get("severity", "medium"),  # Extract from Perplexity or default
                        source=source_info,
                        source_type=self.search_type,
                        target_models=item.get("target_models", []),  # Extract from Perplexity or empty
                        status="active",
                        discovered_date=datetime.utcnow()
                    )

                    db.add(exploit)
                    total_added += 1
                    print(f"  ✓ Added: {exploit.cve_id} - {exploit.title[:50]}")

                await db.commit()

                # Small delay to avoid rate limiting
                await asyncio.sleep(3 if self.search_type == "web" else 2)

            except Exception as e:
                errors.append(f"Query '{query}': {str(e)}")
                await db.rollback()
                print(f"  ✗ Error: {str(e)}")

        return {
            "total_found": total_found,
            "total_added": total_added,
            "total_duplicates": total_duplicates,
            "errors": errors,
            "search_type": self.search_type,
            "citations": list(set(all_citations))  # Unique citations
        }

    # Keep legacy method for backwards compatibility
    async def scrape_from_huggingface(self, db: AsyncSession, queries: List[str] = None) -> Dict[str, Any]:
        """Legacy method - redirects to scrape_exploits"""
        return await self.scrape_exploits(db, queries)

    async def close(self):
        """Close the HTTP client"""
        await self.search_service.close()
